{% extends "core/base.html" %}
{% load static %}

{% block title %}Single Machine Scheduling - Introduction{% endblock %}

{% block styles %}
    <link rel="stylesheet" href="{% static 'core/css/instruction.css' %}">
    <link rel="stylesheet" href="{% static 'core/css/model.definition.css' %}">
{% endblock %}

{% block content %}
<div class="container-fluid introduction-content">
    <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
        <h2>단일 기계 스케줄링 (Single Machine Scheduling)</h2>
    </div>

    <h3>1. 문제 설명</h3>
    <p>
        <strong>단일 기계 스케줄링 문제</strong>는 여러 개의 작업(Job)을 단 하나의 기계(Machine) 또는 자원에서 처리해야 할 때,
        어떤 순서로 작업을 처리해야 특정 목표를 최적화할 수 있는지를 결정하는
        가장 기본적이면서도 중요한 스케줄링 문제입니다. 이는 모든 복잡한 스케줄링 이론의 출발점이 됩니다.
    </p>

    <figure>
        <img src="{% static 'production_scheduling_app/images/single_machine_concept.png' %}"
             alt="단일 기계 스케줄링 문제 개념도" class="intro-image" style="max-width: 600px;">
        <figcaption class="image-caption">그림 1: 작업 처리 순서에 따라 전체 시스템의 효율성이 크게 달라집니다. 최적의 순서는 목표에 따라 결정됩니다.</figcaption>
    </figure>

    <h3>2. 산업 응용 분야</h3>
    <ul>
        <li><strong>제조업:</strong> 생산 라인에서 유일한 병목 현상을 일으키는 특정 기계의 작업 처리 순서 결정.</li>
        <li><strong>IT 서비스:</strong> 한 명의 전문가 또는 단일 고성능 서버가 처리해야 할 요청들의 처리 순서 결정.</li>
        <li><strong>품질 검사:</strong> 단 하나의 고가 테스트 장비를 여러 제품이 공유할 때, 검사 순서를 최적화하여 장비 가동률을 높이고 대기 시간을 줄입니다.</li>
        <li><strong>물류 센터:</strong> 단 하나의 상/하역 도크(Dock)를 여러 트럭이 사용할 때, 도크 작업 순서를 정하여 트럭의 총 대기 시간을 최소화합니다.</li>
    </ul>

    <h3>3. 수학적 모델</h3>
    <p> 가장 대표적인 목표 중 하나인 <strong>총 흐름 시간 최소화</strong> 문제는 다음과 같이 모델링 될 수 있습니다. </p>

    <div class="col-md-8 model-definition-content">
        <h4 class="model-definition-content"><strong>입력 데이터:</strong></h4>
        <ul>
            <li><strong>\( i, k \in \{1, 2, \dots, n\} \)</strong> : 작업(Job)의 인덱스. n은 총 작업의 수</li>
            <li><strong>\( p_{j} \)</strong> : 작업 \( i \) 을 기계에서 처리하는데 걸리는 시간(Processing time)</li>
        </ul>
        <hr>

        <h4 class="model-definition-content"><strong>결정 변수:</strong></h4>
        <ul>
            <li><strong>\( x_{ik} \)</strong> : 작업 \( i \) 가 \( k \) 번째 위치에 배정되면 1, 아니면 0(이진 변수)</li>
            <li><strong>\( C_{i} \)</strong> : 작업 \( i \)의 완료 시간 변수,
                이 변수는 \( x_{ik} \)에 의해 순서가 결정된 후 계산될 수도 있고, 모델 내에서 직접 최적화될 수도 있습니다. (연속 변수)</li>
        </ul>

        <h4 class="model-definition-content"><strong> 목표 함수:</strong></h4> 총 완료 시간 최소화
         <div class="math-block">
            $$\min \sum_{i=1}^{n} C_i = \min \sum_{k=1}^{n} \sum_{i=1}^{n} p_i \cdot x_{ik} \cdot (n - k + 1)$$
        </div>

        <h4 class="model-definition-content"><strong>제약 조건</strong></h4>
        <ul>
            <li><strong>작업 위치 제약:</strong> 각 작업은 정확히 하나의 작업 위치만 배정
                <div class="math-block">
                    $$\sum_{k=1}^{n} x_{ik} = 1, \quad \forall i$$
                </div>
            </li>
            <li><strong>단일 자원 제약 제약:</strong> 기계는 한 번에 오직 하나의 작업만 처리
                <div class="math-block">
                    $$\sum_{i=1}^{n} x_{ik} = 1, \quad \forall k$$
                </div>
            </li>
        </ul>

        <p>
           이러한 기본적인 제약 하에서, 문제의 핵심은 "어떤 순서로 작업을 나열할 것인가"라는 순서(Sequencing) 문제를 푸는 것이 됩니다.
        </p>
    </div>

    <h3>4. Single Machine Demo</h3>
    <p>
        <strong>Single Machine Demo</strong>에서는
        사용자가 <strong>작업 정보</strong>와 <strong>최적화 목표</strong>를 을 입력하여 생산 계획을 수립하는 과정을 체험할 수 있습니다.
    </p>
</div>

<div class="highlight-box">
    <h4>🔬 두 가지 다른 수학적 모델 접근법</h4>
    <p>
        단일 기계 스케줄링 문제는 주로 두 가지 방식으로 모델링될 수 있습니다.
        소개 페이지에서는 이해하기 쉬운 <strong>할당(Assignment) 모델</strong>을 설명했지만,
        실제 데모에서는 더 강력하고 유연한 <strong>시간 기반(Time-based) 모델</strong>을 사용합니다.
    </p>

    <table class="table table-bordered comparison-table mt-3">
        <thead class="thead-light">
            <tr>
                <th>특징</th>
                <th>1. 할당(Assignment) 기반 모델 (소개 페이지)</th>
                <th>2. 시간(Interval) 기반 모델 (데모 구현)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>접근 방식</strong></td>
                <td>혼합 정수 계획법 (MIP)</td>
                <td>제약 프로그래밍 (CP-SAT)</td>
            </tr>
            <tr>
                <td><strong>핵심 질문</strong></td>
                <td>"어떤 작업을 <strong>몇 번째 순서</strong>에 놓을까?"</td>
                <td>"각 작업을 <strong>언제 시작하고 끝낼까</strong>?"</td>
            </tr>
            <tr>
                <td><strong>주요 변수</strong></td>
                <td>\( x_{ik} \) (작업 i를 순서 k에 할당할지 여부)</td>
                <td>\( \text{start}_i, \text{end}_i, \text{interval}_i \) (작업 \( i \)의 시작, 종료, 기간)</td>
            </tr>
            <tr>
                <td><strong>기계 독점 제약</strong></td>
                <td>각 순서 \( k \) 에는 하나의 작업만 할당 (\(\sum_{i} x_{ik} = 1\))</td>
                <td>모든 작업의 Interval들이 겹치지 않음 (<code>AddNoOverlap</code>)</td>
            </tr>
             <tr>
                <td><strong>장점</strong></td>
                <td>구조가 간단하여 이해하기 쉬움.</td>
                <td>준비 시간, 납기일 등 현실적인 제약 추가가 매우 유연하고 강력함.</td>
            </tr>
             <tr>
                <td><strong>적합한 문제</strong></td>
                <td>단순한 할당 및 순서 문제</td>
                <td>복잡한 제약 조건이 포함된 스케줄링 문제</td>
            </tr>
        </tbody>
    </table>

    <h5 class="mt-4">왜 데모에서는 제약 프로그래밍을 사용했나요?</h5>
    <p>
        <strong>제약 프로그래밍</strong>으로 구현 시 각 작업의 시작, 종료, 처리 시간을 하나의 '구간' 객체로 묶어주는 AddNoOverlap 기능을 사용할 수 있습니다.
    </p>
    <p>
        <strong>AddNoOverlap(interval_vars)</strong> 제약은 이 '구간'들의 리스트를 받아, "이 구간들은 타임라인 위에서 서로 절대 겹칠 수 없다"는 규칙을 단 한 줄로 정의합니다.
        이것이 바로 '단일 기계는 한 번에 하나의 작업만 처리할 수 있다'는 제약 조건을 가장 자연스럽고 효율적으로 표현하는 방법입니다.
    </p>
    <p>
        만약 할당(Assignment) 기반 모델에서 이 겹침 방지 제약을 구현하려면,
        모든 작업 쌍에 대해 복잡한 'Big M' 제약식을 여러 개 추가해야 합니다.
        따라서 CP-SAT의 `AddNoOverlap`을 사용하는 것이 훨씬 더 간결하고 강력하며, 더 복잡한 스케줄링 문제로 확장하기에도 용이합니다.
    </p>
</div>
{% endblock %}

{% block scripts %}
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
{% endblock %}