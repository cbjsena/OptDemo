{% extends "core/base.html" %}
{% load static %}

{% block title %}Flow Shop Scheduling - Introduction{% endblock %}

{% block styles %}
    <link rel="stylesheet" href="{% static 'core/css/instruction.css' %}">
    <link rel="stylesheet" href="{% static 'core/css/model.definition.css' %}">
<style>
        .highlight-box {
            background-color: #e9f7fd;
            border-left: 5px solid #007bff;
            padding: 20px;
            margin: 25px 0;
            border-radius: 4px;
        }
        .highlight-box h4 {
            margin-top: 0;
            color: #0056b3;
            border-bottom: 1px dashed #007bff;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .comparison-table {
            font-size: 0.95rem;
        }
    </style>
{% endblock %}

{% block content %}
<div class="container-fluid introduction-content">
    <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
        <h2>흐름 공정 스케줄링 (Flow Shop Scheduling)</h2>
    </div>

    <h3>1. 문제 설명</h3>
    <p>
        <strong>흐름 공정 스케줄링 문제</strong>는 여러 개의 작업(Job)이 모두 동일한 순서로 여러 대의 기계(Machine)를 거쳐
        가공되는 생산 환경에서의 순서 최적화 문제입니다.
        예를 들어, 모든 제품이 <strong>1번 기계(절단) &rarr; 2번 기계(용접) &rarr; 3번 기계(도색)</strong> 순서로 처리되는 경우를 말합니다.
    </p>
    <p>
        이 문제의 목표는 모든 작업이 마지막 기계까지 처리를 완료하는 총 소요 시간,
        즉 <strong>전체 작업 완료 시간(Makespan)</strong>을 최소화하는 최적의 작업 투입 순서(sequence)를 찾는 것입니다.
    </p>
    <figure>
        <img src="{% static 'production_scheduling_app/images/flow_shop_concept.png' %}"
             alt="흐름 공정 스케줄링 문제 개념도" class="intro-image" style="max-width: 600px;">
        <figcaption class="image-caption">그림 1: 모든 작업이 고정된 기계 순서(M1 &rarr; M2 &rarr; M3)를 따를 때, 작업 투입 순서에 따라 전체 완료 시간이 어떻게 달라지는지를 보여줍니다.</figcaption>
    </figure>

    <h4>플로우샵의 종류 </h4>
    <ul>
        <li><strong>순열 플로우샵 (Permutation Flow Shop):</strong>
            가장 일반적인 형태로, 모든 기계에서 작업의 처리 순서가 동일하게 유지됩니다.
            즉, 한 번 결정된 작업 순서(예: A->B->C)는 M1, M2, M3...에서 모두 똑같이 적용됩니다.</li>
        <li><strong>유연 플로우샵 (Flexible Flow Shop):</strong>
            각 공정 단계에 동일한 기능을 하는 기계가 여러 대 있는 경우입니다.
            예를 들어, 1단계(절단)에 2대의 기계, 2단계(가공)에 3대의 기계를 두어 유연성을 높인 생산 환경입니다.
            이 경우 작업 순서뿐만 아니라 각 단계에서 어떤 기계에 작업을 할당할 것인지도 결정해야 합니다.</li>
    </ul>

    <h4>해결 방법(Solution Methods) </h4>
    <ul>
        <li><strong>2-기계 문제:</strong> 존슨의 알고리즘 (Johnson's Algorithm)으로 최적해를 찾을 수 있습니다.</li>
        <li><strong>3-기계 이상 문제:</strong> NP-hard 문제로, 최적해를 찾는 데 매우 오랜 시간이 걸릴 수 있습니다.
            따라서 CDS 휴리스틱, NEH 휴리스틱 방법이나, 정수 계획법(MIP),
            제약 프로그래밍(CP)과 같은 최적화 솔버를 사용합니다.</li>
    </ul>

    <h3>2. 산업 응용 분야</h3>
    <p>공정의 순서가 고정된 많은 조립 라인 및 연속 공정에서 이 모델을 활용할 수 있습니다.</p>
    <ul>
        <li><strong>조립 라인 제조업:</strong> 자동차, 가전제품, 스마트폰 등 부품이 일정한 순서로 조립되는 생산 라인의 효율성을 극대화합니다.</li>
        <li><strong>인쇄 및 출판:</strong> 인쇄 &rarr; 코팅 &rarr; 재단 &rarr; 제본 순서로 진행되는 공정에서 책이나 인쇄물의 생산 시간을 최소화합니다.</li>
        <li><strong>식품 가공:</strong> 원료 준비 &rarr; 조리 &rarr; 냉각 &rarr; 포장 등 정해진 순서를 따르는 식품 생산 라인의 처리량을 높입니다.</li>
        <li><strong>반도체 일부 공정:</strong> 웨이퍼(Wafer)가 특정 장비들을 순서대로 거쳐가는 일부 연속 공정의 스케줄링에 적용됩니다.</li>
    </ul>

    <h3>3. 수학적 모델 및 해법</h3>
    <p> 가장 일반적인 순열 플로우샵(Permutation Flow Shop) 환경에서
        <strong>총 완료 시간(Makespan) 최소화</strong>문제는 다음과 같이 모델링 될 수 있습니다.</p>

    <div class="col-md-8 model-definition-content">
        <h4 class="model-definition-content"><strong>입력 데이터:</strong></h4>
        <ul>
            <li><strong>\( i, k \in \{1, 2, \dots, n\} \)</strong> : 작업(Job)의 인덱스. n은 총 작업의 수</li>
            <li><strong>\( j \in \{1, 2, \dots, m\} \)</strong> : 기계(Machine)의 인덱스. m은 총 기계의 수</li>
            <li><strong>\( p_{ij} \)</strong> : 작업 \( i \) 를 기계 \( j \)에서 처리하는데 걸리는 시간(Processing time)</li>
            <li><strong>\( BigM \)</strong> : 매우 큰 양의 상수</li>
        </ul>
        <hr>

        <h4 class="model-definition-content"><strong>결정 변수:</strong></h4>
        <ul>
            <li><strong>\( C_{ij} \)</strong> : 작업 \( i \) 가 기계 \( j \)에서 처리를 마치는 완료 시간(Completion time)</li>
            <li><strong>\( C_{max} \)</strong> : 모든 작업이 완료되는 시간 (Makespan)</li>
            <li><strong>\( y_{ik} \)</strong> : 작업의 순서를 결정하는 이진 변수(Binary variable),
                작업 \( i \) 가 작업 \( k \) 이전에 계획되면 1, 아니면 0</li>
        </ul>

        <h4 class="model-definition-content"><strong> 목표 함수:</strong></h4>
        <p>전체 작업 완료 시간(Makespan) 최소화. 이는 마지막 순서의 작업이 마지막 기계에서 완료되는 시간과 같습니다. </p>
        <div class="math-block">
            $$ \min C_{max} = \min (\max_{i=1, \dots, n} C_{im}) $$
        </div>

        <h4 class="model-definition-content"><strong>제약 조건</strong></h4>
        <ul>
            <li><strong>기계 순서 제약 (작업 흐름)</strong>
                <p>한 작업은 이전 단계의 기계에서 처리가 완료되어야만 다음 단계의 기계를 사용할 수 있습니다.
                    예를 들어, 작업 \( i \)는 기계 \( j \)−1에서 완료된 후에야 기계 \( j \)에서 가공을 시작할 수 있습니다.</p>
                <div class="math-block">
                    <p>$$ C_{ij} \ge C_{i, j-1} + p_{ij} \quad (\forall i=1,..,n, \forall j=2,..,m) $$</p>
                    <p>첫 번째 기계 (\( j \)=1)에 대해서는 이전 기계가 없으므로, \( C_{i1} \ge p_{i1} \)입니다.
                        위의 제약식에서 \( C_{i0} = 0 \) 으로 가정하면 동일하게 표현됩니다.</p>
                </div>
            </li>
            <li><strong>작업 순서 제약 (기계 독점)</strong>
                <p>각 기계는 한 번에 하나의 작업만 처리할 수 있습니다.
                    따라서 어떤 두 작업 \( i \) 와 \( k \) 에 대해, 한 기계 위에서는 둘 중 하나가 반드시 먼저 끝나야 합니다. </p>
                <div class="math-block">
                    $$ C_{kj} \ge C_{ij} + p_{kj} -BigM (1 - y_{ik})\quad (\forall j=1,\dots,m; \forall i, k \text{ where } i \ne k) $$
                    $$ C_{ij} \ge C_{kj} + p_{ij} -BigM y_{ik}\quad (\forall j=1,\dots,m; \forall i, k \text{ where } i \ne k) $$
                    <p>위 두 제약식은 \( y_{ik} \) 값에 따라 둘 중 하나만 실질적인 제약으로 기능하게 만듭니다.
                    만약 \( y_{ik} = 1 \) 이면 첫 번째 식은 \( C_{kj} \ge C_{ij} + p_{kj} \)가 되고, 두 번째 식은 \( BigM \) 때문에 무의미해집니다.</p>
                </div>
            </li>
            <li><strong>이진 변수 조건:</strong> 두 작업 \( i \) 와 \( k \)의 순서는 반드시 하나로 결정
                <div class="math-block">
                    $$ y_{ik} + y_{ki} = 1 \quad (\forall i, k \text{ where } i < k)$$
                </div>
            </li>
            <li><strong>변수 타입 및 범위:</strong> 모든 완료 시간은 0 이상
                <div class="math-block">
                    $$ C_{ij} \ge 0, C_{max} \ge 0$$
                </div>
            </li>
        </ul>
    </div>
    <h3>4. Flow Shop Demo</h3>
    <p>
        <strong>Flow Shop Demo</strong>에서는
        사용자가 ???을 입력하여
        ??? 최소화하는 생산 계획을 수립하는 과정을 체험할 수 있습니다.
    </p>

    <div class="highlight-box">
        <h4>💡 단일 기계 스케줄링과의 차이점</h4>
        <p>Flow Shop 스케줄링은 Single Machine 스케줄링의 확장된 형태이지만, 여러 기계가 순차적으로 연결되면서 새로운 복잡성이 발생합니다.</p>
        <table class="table table-bordered comparison-table">
            <thead class="thead-light">
                <tr>
                    <th>구분</th>
                    <th>단일 기계 스케줄링 (Single Machine)</th>
                    <th>흐름 공정 스케줄링 (Flow Shop)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>기계 수</strong></td>
                    <td>1대</td>
                    <td>2대 이상 (m ≥ 2)</td>
                </tr>
                <tr>
                    <td><strong>작업 흐름</strong></td>
                    <td>모든 작업이 하나의 기계에서 완료됨</td>
                    <td>모든 작업이 동일한 순서로 여러 기계를 거쳐 감 (M1 &rarr; M2 ...)</td>
                </tr>
                <tr>
                    <td><strong>핵심 문제</strong></td>
                    <td>작업 순서(Sequence) 결정</td>
                    <td>모든 기계에 동일하게 적용될 작업 순서(Sequence) 결정</td>
                </tr>
                <tr>
                    <td><strong>주요 목표</strong></td>
                    <td>다양함 (Makespan, Total Flow Time, Tardiness 등)</td>
                    <td>주로 Makespan 최소화에 집중</td>
                </tr>
                <tr>
                    <td><strong>복잡성</strong></td>
                    <td>목표에 따라 다름 (일부는 간단한 규칙으로 해결 가능)</td>
                    <td>기계가 3대 이상이 되면 NP-hard 문제로 매우 복잡해짐</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="highlight-box">
        <h4>⚙️ 특수 해법: 2-기계 문제와 존슨의 알고리즘 (Johnson's Algorithm)</h4>
        <p>
            기계가 단 두 대뿐인 흐름 공정 문제\( m=2 \)에서 \( C_{max} \)을 최소화하는 최적의 작업 순서는
            <strong>존슨의 알고리즘</strong>이라는 간단한 규칙으로 찾을 수 있습니다.
            이는 다항 시간 내에 최적해를 보장하는 매우 효율적인 방법입니다.
        </p>
        <p><strong>알고리즘 절차:</strong></p>
        <ol>
            <li>모든 작업 \( i \) 에 대해 1번 기계에서의 처리 시간 \( p_{i1} \) 과
                2번 기계에서의 처리 시간 \( p_{i2} \) 을 나열합니다.</li>
            <li>아직 순서가 정해지지 않은 작업들 중에서 가장 작은 처리 시간을 찾습니다.</li>
            <li>
                만약 가장 작은 처리 시간이:
                <ul>
                    <li><strong>1번 기계</strong>에 속한다면, 해당 작업을 가능한 한 가장 앞 순서에 배치합니다.</li>
                    <li><strong>2번 기계</strong>에 속한다면, 해당 작업을 가능한 한 가장 뒷 순서에 배치합니다.</li>
                </ul>
            </li>
            <li>순서가 결정된 작업은 목록에서 제외합니다.</li>
            <li>모든 작업의 순서가 결정될 때까지 2~4단계를 반복합니다.</li>
        </ol>
        <p>
            예를 들어, 어떤 작업의 처리 시간이 1번 기계에서 가장 짧다면,
            그 작업을 맨 처음에 수행하는 것이 전체 공정의 대기 시간을 줄이는 데 가장 유리하다는 직관에 기반합니다.
        </p>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
{% endblock %}