{% extends "core/base.html" %}
{% load static %}

{% block title %}Job Shop Scheduling - Introduction{% endblock %}

{% block styles %}
    <link rel="stylesheet" href="{% static 'core/css/instruction.css' %}">
    <link rel="stylesheet" href="{% static 'core/css/model.definition.css' %}">
{% endblock %}

{% block content %}
<div class="container-fluid introduction-content">
    <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
        <h2>작업장 일정 계획 문제 (Job Shop Scheduling)</h2>
    </div>

    <p><strong>작업장 일정 계획 문제(Job Shop Scheduling Problem, JSSP)</strong>는
        여러 개의 작업(Job)과 여러 개의 기계(Machine)가 주어졌을 때,
        각 작업의 공정을 순서에 맞게 특정 기계에서 수행해야 하는 상황에서, 전체 스케줄을 최적화하는 문제입니다.
    </p>
    <figure>
        <img src="{% static 'production_scheduling_app/images/job_shop_concept.png' %}"
             alt="작업장 일정 계획 문제 개념도" class="intro-image" style="max-width: 600px;">
        <figcaption class="image-caption">그림 1: 각 작업(Job A, Job B)이 서로 다른 기계 순서(Routing)를 가집니다. 이로 인해 기계 점유를 위한 경쟁이 발생하며, 복잡한 스케줄링 문제가 됩니다.</figcaption>
    </figure>

    <div class="row">
        <div class="col-lg-8">
            <h3>1. 문제 설명</h3>
            <p> 이 문제는 각 작업이 거쳐가는 기계의 순서가 서로 다르기 때문에
                이는 모든 작업이 동일한 순서로 기계를 거쳐가는 흐름 공정(Flow Shop)보다 훨씬 더 복잡합니다.
                문제의 목표는 보통 모든 작업이 완료되는 총 소요 시간, 즉 전체 작업 완료 시간(Makespan)을 최소화하는 최적의 작업 순서와 기계별 작업 계획을 수립하는 것입니다.
            </p>
            <p>흐름 공정(Flow Shop)과 마찬가지로 수리적 모델을 이용하여 문제를 해결할 수 있으나
            작업마다 기계 순서가 다르기 때문에 제약 조건이 훨씬 복잡해지므로 매우 복잡하여 최적해를 찾기 어려울 수도 있습니다.
            상황과 문제의 크기에 따라 아래 소개하는 간단한 우선 순위나 휴리스틱 접근법을 이용하기도 합니다.
            </p>
            <h4>해결 방법(Solution Methods) </h4>
            <ul>
                <li><strong>SPT(Shortest Processing Time):</strong> 처리 시간이 가장 짧은 작업을 먼저 처리</li>
                <li><strong>FCFS(First Come, First Served):</strong> 기계에 먼저 도착한 작업을 먼저 처리</li>
                <li><strong>EDD (Earliest Due Date):</strong> 납기일이 가장 빠른 작업을 우선 처리</li>
                <li><strong>MWKR (Most Work Remaining):</strong> 앞으로 남은 공정의 총 처리 시간이 가장 긴 작업을 우선 처리, 중요한 작업을 먼저 끝내려는 시도</li>
                <li><strong>CR (Critical Ratio): </strong> (납기까지 남은 시간) / (남은 총 작업 시간)의 비율을 계산하여, 가장 작은 값(가장 급한 작업)을 먼저 처리</li>
                <li><strong>Shifting Bottleneck Heuristic:</strong> 부하가 많이 걸리는 Bottleneck 기계의 작업 순서부터 결정하여 순차적으로 처리</li>
            </ul>

            <h3>2. 산업 응용 분야</h3>
            <p>주문 사양에 따라 생산 공정이 달라지는 다품종 소량생산 환경에서 널리 적용됩니다.</p>
            <ul>
                <li><strong>기계 부품 가공 공장:</strong> 각기 다른 설계 도면에 따라 선반, 밀링, 드릴링 등 다양한 공작 기계를 다른 순서로 거쳐야 하는 부품 생산 계획.</li>
                <li><strong>반도체 제조 공정:</strong> 다양한 종류의 반도체 칩이 설계에 따라 포토(Photo), 에칭(Etch), 증착(Deposition) 등 수백 개의 공정을 각기 다른 순서로 거치는 스케줄링.</li>
                <li><strong>주문형 가구 제작:</strong> 고객의 주문에 따라 목재 재단, 조립, 샌딩, 도색 등 작업의 순서와 종류가 달라지는 생산 계획.</li>
                <li><strong>병원 환자 관리:</strong> 각 환자가 진료, X-레이 촬영, 혈액 검사, 물리 치료 등 필요한 처치를 다른 순서로 받아야 할 때, 병원 내 자원(의사, 장비, 검사실)의 사용 계획을 최적화.</li>
            </ul>

            <h3>3. 수학적 모델</h3>
            <div class="model-definition-content">
                <h4 class="model-definition-content"><strong>입력 데이터:</strong></h4>
                <ul>
                    <li><strong>\( i, k \in \{1, 2, \dots, n\} \)</strong> : 작업(Job)의 인덱스. n은 총 작업의 수</li>
                    <li><strong>\( j \in \{1, 2, \dots, m\} \)</strong> : 기계(Machine)의 인덱스. m은 총 기계의 수</li>
                    <li><strong>\( O \)</strong> : 작업 내 공정(Operation)의 순서 번호</li>
                    <li><strong>\( O_{ij} \)</strong> : 작업 \( i \) 의 공정 중 기계 \( j \)를 사용하는 공정 번호.(\( O_{1,3} = 2\): 작업 1의 2번째 공정이 기계 3을 사용)</li>
                    <li><strong>\( M_{io} \)</strong> : 작업 \( i \) 의 \( o \) 번째 공정에서 사용되는 기계의 번호</li>
                    <li><strong>\( p_{io} \)</strong> : 작업 \( i \) 의 \( o \) 번째 공정에 걸리는 시간(Processing time)</li>
                    <li><strong>\( BigM \)</strong> : 매우 큰 양의 상수</li>
                </ul>
                <hr>

                <h4 class="model-definition-content"><strong>결정 변수:</strong></h4>
                <ul>
                    <li><strong>\( S_{io} \)</strong> : 작업 \( i \) 의 \( o \) 번째 공정의 시작 시간</li>
                    <li><strong>\( C_{max} \)</strong> : 모든 작업이 완료되는 시간 (Makespan)</li>
                    <li><strong>\( y_{ikj} \)</strong> : 기계 \( j \) 에서 작업 \( i \), 작업 \( k \) 의 순서를 결정하는 이진변수,
                        작업 \( i \) 가 작업 \( k \) 이전에 진행되면 1, 아니면 0</li>
                </ul>

                <h4 class="model-definition-content"><strong> 목표 함수:</strong></h4>
                <p>전체 작업 완료 시간(Makespan) 최소화. 이는 마지막 순서의 작업이 마지막 기계에서 완료되는 시간과 같습니다. </p>
                <div class="math-block">
                    $$ \min C_{max} $$
                </div>

                <h4 class="model-definition-content"><strong>제약 조건</strong></h4>
                <ul>
                    <li><strong>Makespan \( C_{max} \)의 정의:</strong>
                        <p>Makespan은 모든 작업의 <strong>마지막 공정이 완료되는 시간</strong>들 중 가장 큰 값보다 크거나 같다.</p>
                        <div class="math-block">
                            $$ C_{max} \ge  S_{io} + p_{io} \quad (\forall i, o \text{ where } o \text{ is the last operation of job } i)$$
                        </div>
                    </li>
                    <li><strong>작업 내 공정 순서 제약 (Precedence Constraint)</strong>
                        <p>각 작업은 자신에게 주어진 고유한 공정 순서를 반드시 따라야 합니다.
                            즉, \( o + i \) 번째 공정은 \( o \) 번째 공정이 완료된 후에만 시작할 수 있습니다.</p>
                        <div class="math-block">
                            <p>$$ S_{i, o+1} \ge S_{i, o} + p_{io} \quad (\forall i, o \text{ where } o \text{ is not the last operation of job } i)$$</p>
                            <p>이 제약식이 각 작업의 고유한 라우팅(Unique Routing)을 강제</p>
                        </div>
                    </li>
                    <li><strong>기계 독점 제약 (Capacity Constraint)</strong>
                        <p>각 기계는 한 번에 하나의 작업만 처리할 수 있습니다.
                            만약 두 작업 \( i \) 와 \( k \) 가 모두 기계 \( j \)를 사용해야 한다면,
                            둘 중 하나의 작업이 완전히 끝난 후에야 다른 작업이 시작될 수 있습니다. </p>
                        <div class="math-block">
                            $$ S_{ko'} \ge S_{io} + p_{io} - BigM (1 - y_{ikj}) \quad (\forall i, o \text{ where } M_{io} = M_{ko'} = j)$$
                            $$ S_{ko'} \ge S_{io} + p_{io} - BigM y_{ikj} \quad (\forall i, o \text{ where } M_{io} = M_{ko'} = j)$$
                            <p>만약 \( y_{ikj} = 1 \) 이면 첫 번째 식에 의해서 기계 \( j \) 에서 작업 \( i \) 가 작업 \( k \) 보다 먼저 작업 합니다.<br>
                            반대로 \( y_{ikj} = 0 \) 이면 두 번째 식에 의해서 기계 \( j \) 에서 작업 \( i \) 가 작업 \( k \) 보다 나중에 작업 합니다.<br>
                            즉 y_{ikj} 값에 따라 두 제약식 중 하나만 작용하여 두 작업이 기계 \( j \)에서 겹치지 않도록 보장합니다.  </p>
                        </div>
                    </li>
                    <li><strong>변수 타입 및 범위:</strong> 모든 완료 시간은 0 이상
                        <p>모든 시작 시간은 0보다 커야 합니다.</p>
                        <div class="math-block">
                            $$ S_{ij} \ge 0, C_{max} \ge 0$$
                        </div>
                    </li>
                </ul>
            </div>
        </div>

        <div class="col-lg-4">
            <div class="card shadow-sm sticky-top" style="top: 20px;">
                <div class="card-header bg-success text-white">
                    <h4>Job Shop Demo</h4>
                </div>
                <div class="card-body">
                    <p><strong>Job Shop Demo</strong>에서는 아래와 같은 기능을 직접 체험해볼 수 있습니다.</p>
                    <ul>
                        <li>작업 수와 기계 수를 설정</li>
                        <li>작업별 기계 처리 시간과 공정 순서 정보 입력</li>
                        <li>전체 작업 완료 시간(Makespan)을 최소화하는 생산 계획 확인</li>
                    </ul>
                    <a href="{% url 'production_scheduling_app:job_shop_demo' %}" class="btn btn-success mt-2">
                        데모 페이지로 이동 &rarr;
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}