{% extends "core/base.html" %}
{% load static %}

{% block title %}Single Machine Scheduling - Introduction{% endblock %}

{% block styles %}
    <link rel="stylesheet" href="{% static 'core/css/instruction.css' %}">
    <link rel="stylesheet" href="{% static 'core/css/model.definition.css' %}">
{% endblock %}

{% block content %}
<div class="container-fluid introduction-content">
    <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
        <h1 class="h2">단일 기계 스케줄링 (Single Machine Scheduling)</h1>
    </div>

    <h4>1. 문제 설명</h4>
    <p>
        <strong>단일 기계 스케줄링 문제</strong>는 여러 개의 작업(Job)을 단 하나의 기계(Machine) 또는 자원에서 처리해야 할 때, **어떤 순서로 작업을 처리**해야 특정 목표를 최적화할 수 있는지를 결정하는 가장 기본적이면서도 중요한 스케줄링 문제입니다. 이는 모든 복잡한 스케줄링 이론의 출발점이 됩니다.
    </p>
    <p>
        각 작업은 고유한 처리 시간, 납기일, 중요도 등의 속성을 가지며, 최적화의 목표는 이러한 속성들을 바탕으로 가장 효율적인 작업 순서(sequence)를 찾는 것입니다.
    </p>
    <figure>
        <img src="{% static 'production_scheduling_app/images/single_machine_concept.png' %}"
             alt="단일 기계 스케줄링 문제 개념도" class="intro-image" style="max-width: 600px;">
        <figcaption class="image-caption">그림 1: 작업 처리 순서에 따라 전체 시스템의 효율성이 크게 달라집니다. 최적의 순서는 목표에 따라 결정됩니다.</figcaption>
    </figure>

    <h4>2. 산업 응용 분야</h4>
    <ul>
        <li><strong>제조업:</strong> 생산 라인에서 유일한 병목 현상을 일으키는 특정 기계의 작업 처리 순서 결정.</li>
        <li><strong>IT 서비스:</strong> 한 명의 전문가 또는 단일 고성능 서버가 처리해야 할 요청들의 처리 순서 결정.</li>
        <li><strong>품질 검사:</strong> 단 하나의 고가 테스트 장비를 여러 제품이 공유할 때, 검사 순서를 최적화하여 장비 가동률을 높이고 대기 시간을 줄입니다.</li>
        <li><strong>물류 센터:</strong> 단 하나의 상/하역 도크(Dock)를 여러 트럭이 사용할 때, 도크 작업 순서를 정하여 트럭의 총 대기 시간을 최소화합니다.</li>
    </ul>

    <h4>3. 수학적 모델</h4>
    <div class="col-md-8 model-definition-content">
        <strong>주요 변수 및 파라미터:</strong>
        <div class="math-block">
            <p>$$ p_j = \text{Processing time of job } j $$</p>
            <p>$$ d_j = \text{Due date of job } j $$</p>
            <p>$$ w_j = \text{Weight (importance) of job } j $$</p>
            <p>$$ C_j = \text{Completion time of job } j \text{ (a result of scheduling)} $$</p>
        </div>

        <strong>대표적인 목표 함수:</strong>
        <ul>
            <li>
                <strong>총 완료 시간 최소화 (Minimizing Total Completion Time)</strong>
                <p>시스템 내 작업들의 평균 대기 시간을 줄이는 것과 같습니다. 이는 **SPT (Shortest Processing Time)** 규칙, 즉 처리 시간이 짧은 작업부터 순서대로 처리하여 최적해를 찾을 수 있습니다.</p>
                <div class="math-block">
                    $$\min \sum_{j} C_j$$
                </div>
            </li>
            <li>
                <strong>최대 지연 시간 최소화 (Minimizing Maximum Lateness)</strong>
                <p>가장 심각한 납기 위반을 줄이는 데 중점을 둡니다. 이는 **EDD (Earliest Due Date)** 규칙, 즉 납기일이 가장 빠른 작업부터 순서대로 처리하여 최적해를 찾을 수 있습니다.</p>
                <div class="math-block">
                    $$\min (\max_j (L_j)) \quad \text{where } L_j = C_j - d_j$$
                </div>
            </li>
            <li>
                <strong>납기 지연 작업 수 최소화 (Minimizing Number of Tardy Jobs)</strong>
                <p>납기일을 지키지 못하는 작업의 총 개수를 최소화합니다. 이는 **무어-호지슨 알고리즘(Moore-Hodgson's Algorithm)**으로 해결할 수 있습니다.</p>
                <div class="math-block">
                    $$\min \sum_{j} U_j \quad \text{where } U_j = \begin{cases} 1 & \text{if } C_j > d_j \\ 0 & \text{otherwise} \end{cases}$$
                </div>
            </li>
        </ul>

        <hr>

        <strong>주요 제약 조건 (Implicit Constraints):</strong>
        <p>
            단일 기계 스케줄링의 기본 모델은 그 단순함 때문에 제약이 없어 보일 수 있지만, 다음과 같은 중요한 규칙들이 모든 문제에 기본적으로 적용됩니다.
        </p>
        <ul>
            <li>
                <strong>단일 자원 제약 (Single Resource):</strong> 기계는 한 번에 오직 하나의 작업만 처리할 수 있습니다.
                <div class="math-block">
                    <p>$$ \text{If job } j \text{ is being processed at time } t, \text{ no other job } k \text{ can be processed at time } t. $$</p>
                </div>
            </li>
            <li>
                <strong>선점 불가 제약 (Non-preemption):</strong> 일단 작업이 시작되면, 다른 작업 때문에 중간에 중단될 수 없고 반드시 완료되어야 합니다.
            </li>
             <li>
                <strong>작업 가용성 (Job Availability):</strong> 모든 작업은 시간 0 (또는 각 작업의 준비 시간 $r_j$)부터 처리 가능합니다.
            </li>
             <li>
                <strong>연속 처리:</strong> 기계는 유휴 시간(idle time)을 가질 수 있지만, 일반적으로는 가능한 한 빨리 다음 작업을 연속해서 처리합니다.
            </li>
        </ul>
        <p>
           이러한 기본적인 제약 하에서, 문제의 핵심은 "어떤 순서로 작업을 나열할 것인가"라는 순서(Sequencing) 문제를 푸는 것이 됩니다.
        </p>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
{% endblock %}